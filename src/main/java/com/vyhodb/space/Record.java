/*
 * MIT License
 *
 * Copyright (c) 2015-present Igor Vykhodtsev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.vyhodb.space;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Date;
import java.util.Iterator;
import java.util.Set;
import java.util.UUID;

/**
 * Represents vyhodb record and provides methods for operating on it's fields,
 * links and indexes.
 * <p>
 * Record is created by {@linkplain Space#newRecord()} and deleted by
 * {@linkplain #delete()}. Record belong to one and only one {@linkplain Space}
 * object. Each record has <strong>long</strong> identifier which is
 * automatically generated by Space implementation and can be obtainer by
 * {@linkplain #getId()}.
 * 
 * <h5>Fields</h5>
 * Record is a container for fields. Field value is set by
 * {@linkplain #setField(String, Object)} and retrieved by
 * {@linkplain #getField(String)}.
 * <p>
 * Tables below shows supported classes which can be used as a field values.
 * 
 * <p>
 * Classes:
 * <p>
 * <table border="1">
 * <tr>
 * <td>{@linkplain String}</td>
 * <td>{@linkplain Boolean}</td>
 * <td>{@linkplain BigInteger}</td>
 * </tr>
 * <tr>
 * <td>{@linkplain Long}</td>
 * <td>{@linkplain Date}</td>
 * <td>{@linkplain Double}</td>
 * </tr>
 * <tr>
 * <td>{@linkplain Integer}</td>
 * <td>{@linkplain BigDecimal}</td>
 * <td>{@linkplain Float}</td>
 * </tr>
 * <tr>
 * <td>{@linkplain Character}</td>
 * <td>{@linkplain Byte}</td>
 * <td>{@linkplain UUID}</td>
 * </tr>
 * <tr>
 * <td>{@linkplain Short}</td>
 * <td>&nbsp;</td>
 * <td>&nbsp;</td>
 * </tr>
 * </table>
 * 
 * <p>
 * Primitive arrays:
 * <p>
 * <table border="1">
 * <tr>
 * <td>long[]</td>
 * <td>double[]</td>
 * <td>short[]</td>
 * </tr>
 * <tr>
 * <td>int[]</td>
 * <td>float[]</td>
 * <td>byte[]</td>
 * </tr>
 * <tr>
 * <td>boolean[]</td>
 * <td>char[]</td>
 * <td>&nbsp;</td>
 * </tr>
 * </table>
 * 
 * <p>
 * Object arrays:
 * <p>
 * <table border="1">
 * <tr>
 * <td>String[]</td>
 * <td>BigInteger[]</td>
 * </tr>
 * <tr>
 * <td>Date[]</td>
 * <td>UUID[]</td>
 * </tr>
 * <tr>
 * <td>BigDecimal[]</td>
 * <td>&nbsp;</td>
 * </tr>
 * </table>
 * 
 * <h5>Links</h5>
 * Link is created from "child" record and points to "parent" record. Method
 * {@linkplain #setParent(String, Record)} creates, changes or removes link to
 * parent record (so called "parent link"). Method
 * {@linkplain #getParent(String)} retrieves parent record of current "child"
 * record.
 * <p>
 * Child records can be retrieved from "parent" record by
 * {@linkplain #getChildren(String)}.
 * <p>
 * In current implementation, child records are stored as linked list, and when
 * the new link is created, corresponding child record is added to the tail of
 * list.
 * 
 * <h5>Virtual fields</h5>
 * Virtual field is a {@linkplain Long} type field, which name is equal to
 * existed parent link name, and value is a parent record identifier. Virtual
 * fields are read-only fields. Virtual fields can participate in both simple
 * and composite indexes.
 * 
 * <h5>Siblings</h5>
 * Sibling records are records, which have the same parent record with the same
 * link name as current record.
 * <p>
 * Method {@linkplain #getSiblings(String)} retrieves sibling records.
 * 
 * <h5>Indexes</h5> Indexes can be created to speed up search of child records
 * by their field values.
 * <p>
 * Index is created in parent record and visible only from parent record. It
 * indexes child records. Index can be considered as Map structure, where map
 * keys are field values and map elements are child records themselves.
 * <p>
 * {@linkplain IndexDescriptor} class specifies index parameters, including
 * child link name (which records are indexed), and child records field(s)
 * (which values are used as a keys). IndexDescriptor also specifies other index
 * parameters like uniqueness, nullable.
 * <p>
 * Depends on count of indexed fields, index is considered as <b>Simple</b>
 * (only one indexed field) or <b>Composite</b> (two or more indexed fields).
 * Indexes are created by {@linkplain #createIndex(IndexDescriptor)} method.
 * <p>
 * When indexed field of indexed child record is changed, corresponding indexes
 * on parent records are automatically updated. Index is also automatically
 * updated when new child link created/removed.
 * <p>
 * Search child records using index is performed by methods
 * {@linkplain #searchChildren(String, Criterion, Order)},
 * {@linkplain #searchChildrenFirst(String, Criterion, Order)}. They accept
 * index name and search criteria. Records in search result are arranged
 * according to indexed field values. For <b>Simple</b> indexes it is possible
 * to specify order of iteration (see {@linkplain Order}). For <b>Composite</b>
 * indexes <b>order</b> parameter has no meaning and records are always returned
 * in ascending order ({@linkplain Order#ASC}).
 * <p>
 * Note, that index search result iterators do not support
 * {@linkplain Iterator#remove()} method.
 * <p>
 * Indexes are removed by {@linkplain #removeIndex(String)}. Index removing
 * neither removes children links nor children records.
 * 
 * <h5>Records lazy loading</h5>
 * All record iterators (children, siblings, index search results) are lazy
 * iterators: they don't read record (from cache or disk) until
 * {@linkplain Iterator#next()} is called.
 * <p>
 * Method {@linkplain #getParent(String)} follows lazy loading policy as well.
 * 
 * <h5>Fast-fail iterators</h5>
 * All record iterators (children, siblings, index search results) are fast-fail
 * iterator: they throw an exception (and roll back transaction - if applicable)
 * when any modification is done behind iterator itself.
 * <p>
 * For instance adding/removing child record, after retrieving children
 * iterator, would lead to exception an any attempt to use children iterator.
 * <p>
 * Another example: if indexed child record's field value is changed after
 * retrieving search result on corresponding index, then any attempt to iterate
 * over index search result iterator would lead to exception.
 * 
 * <h5>Thread safety</h5> Objects of this interface (as well as returned
 * iterators) are not thread safe.
 * 
 * @see Space
 * @see IndexDescriptor
 * @see Criterion
 * 
 * @author Igor Vykhodtsev
 * @since vyhodb 0.6.0
 */
public interface Record {

    /**
     * Checks whether current record has index with specified index name.
     * 
     * @param indexName
     *            index name
     * @return true if index exists, false otherwise
     */
    public boolean containsIndex(String indexName);

    /**
     * Creates new index on child records.
     * <p>
     * Child link name, indexed field names and other index parameters are
     * defined by {@linkplain IndexDescriptor}.
     * 
     * @see IndexDescriptor
     * @see IndexedField
     * 
     * @param indexDescriptor
     *            index descriptor
     */
    public void createIndex(IndexDescriptor indexDescriptor);

    /**
     * Deletes current record.
     * <p>
     * Root record (id == 0) can't be deleted.
     * <p>
     * Links (parent and child) and indexes are deleted as well.
     */
    public void delete();

    /**
     * Method returns true, when all the following criteria are true:
     * <ol>
     * <li>passed object implements Record interface</li>
     * <li>passed record's id is the same as current record id</li>
     * <li>passed record's space is the same as current record space</li>
     * </ol>
     * 
     * @param object
     *            the object to be compared
     * @return true when object is equal to current record, false otherwise.
     */
    @Override
    public boolean equals(Object object);

    /**
     * Returns first child record.
     * <p>
     * The same as <code>getChildren(linkName).iterator.next()</code>
     * 
     * @param linkName
     *            link name
     * @return first child record or null if there are no children records for
     *         specified link name.
     */
    public Record getChildFirst(String linkName);

    /**
     * Returns last child record.
     * <p>
     * The same as
     * <code>getChildren(linkName, Order.DESC).iterator.next()</code>
     * 
     * @param linkName
     *            link name
     * @return last child record or null if there are no children records for
     *         specified link name.
     */
    public Record getChildLast(String linkName);

    /**
     * Returns child records.
     * <p>
     * Child records are in {@linkplain Order#ASC} order (order in which child
     * links were created).
     * 
     * @param linkName
     *            children link name
     * @return child records
     */
    public Iterable<Record> getChildren(String linkName);

    /**
     * Returns child records.
     * 
     * @param linkName
     *            link name
     * @param order
     *            iterator order
     * @return child records
     */
    public Iterable<Record> getChildren(String linkName, Order order);

    /**
     * Returns count of child records.
     * 
     * @param linkName
     *            child link name
     * @return count of child records
     */
    public long getChildrenCount(String linkName);

    /**
     * Returns names of existed child links.
     * 
     * @return names of existed child links
     */
    public Set<String> getChildrenLinkNames();

    /**
     * Retrieves field value.
     * <p>
     * If value is mutable, then it is cloned before returning.
     * 
     * @param <T>
     * @param fieldName
     *            field name
     * @return field value, if field exists, or null otherwise
     */
    public <T> T getField(String fieldName);

    /**
     * Returns names of existed fields.
     *
     * @return field names
     */
    public Set<String> getFieldNames();

    /**
     * Returns record's id
     *
     * @return record's id
     */
    public long getId();

    /**
     * Returns index descriptor for index with specified index name.
     * 
     * @param indexName
     *            index name
     * @return index descriptor
     */
    public IndexDescriptor getIndexDescriptor(String indexName);

    /**
     * Returns index descriptors of current record's indexes.
     * 
     * @return set of index descriptors
     */
    public Set<IndexDescriptor> getIndexDescriptors();

    /**
     * Returns names of current record's indexes.
     * 
     * @return set of index names
     */
    public Set<String> getIndexNames();

    /**
     * Returns parent record.
     * 
     * @param linkName
     *            link name
     * @return parent record if link exists, null - otherwise
     */
    public Record getParent(String linkName);

    /**
     * Returns names of existed parent links.
     * 
     * @return parent link names
     */
    public Set<String> getParentLinkNames();

    /**
     * Returns siblings of current child record.
     * <p>
     * The same as <code>getSiblings(linkName, Order.ASC).iterator.next()</code>
     * 
     * @param linkName
     *            link name
     * @return record's siblings
     */
    public Iterable<Record> getSiblings(String linkName);

    /**
     * Returns siblings of current child record.
     * 
     * @param linkName
     * @param order
     *            iterator direction
     * @return record's siblings
     */
    public Iterable<Record> getSiblings(String linkName, Order order);

    /**
     * Returns record's space.
     *
     * @return record's space
     */
    public Space getSpace();

    /**
     * Returns record's hash code.
     * <p>
     * Record hash code value is its identifier's long value, casted to
     * <strong>int</strong> type.
     * 
     * @return record's hash code
     */
    @Override
    public int hashCode();

    /**
     * Indicates whether record is deleted or not.
     * 
     * @return true - if record is deleted, false - otherwise
     */
    public boolean isDeleted();

    /**
     * Removes child records.
     * <p>
     * Indexes, which are created on specified child records, are not removed.
     * 
     * @param linkname
     *            child link name
     */
    public void removeChildren(String linkname);

    /**
     * Removes index.
     * <p>
     * Neither child records nor their links are deleted/removed as a result of
     * this method.
     * 
     * @param indexName
     *            removing index name
     */
    public void removeIndex(String indexName);

    /**
     * Searches child records using index.
     * <p>
     * The same as <code>getIndex(indexName, criterion, Order.ASC)</code>. See
     * {@linkplain #searchChildren(String, Criterion, Order)}
     * 
     * @see IndexDescriptor
     * @see IndexedField
     * @see CriterionFactory
     * 
     * @param indexName
     *            index name
     * @param criterion
     *            search criterion
     * @return search result
     */
    public Iterable<Record> searchChildren(String indexName, Criterion criterion);

    /**
     * Searches child records using index.
     * <p>
     * Method returns indexed child records which indexed field(s) satisfy
     * search criterion.
     * <p>
     * Indexed child records and their indexed field(s) are defined by index,
     * which name is specified by <b>indexName</b> parameter.
     * <p>
     * Search result of <b>Composite</b> index is always in
     * {@linkplain Order#ASC} order.
     * 
     * @see IndexDescriptor
     * @see IndexedField
     * @see Criterion
     * @see CriterionFactory
     * 
     * @param indexName
     *            index name
     * @param criterion
     *            search criterion
     * @param order
     *            arrangement order
     * @return child records which field(s) satisfy search criterion
     */
    public Iterable<Record> searchChildren(String indexName, Criterion criterion, Order order);

    /**
     * Returns first record of children search result.
     * <p>
     * The same as
     * <code>searchChildren(indexName, criterion).iterator().next()</code>.
     * <p>
     * See {@linkplain #searchChildren(String, Criterion)}
     * 
     * @param indexName
     *            index name
     * @param criterion
     *            search criterion
     * @return first record of search result - if search result is not empty.
     *         null - if there are no records in search result.
     */
    public Record searchChildrenFirst(String indexName, Criterion criterion);

    /**
     * Returns first record of children search result.
     * <p>
     * The same as
     * <code>searchChildren(indexName, criterion, order).iterator().next()</code>.
     * <p>
     * See {@linkplain #searchChildren(String, Criterion, Order)}
     * 
     * @param indexName
     *            index name
     * @param criterion
     *            search criterion
     * @return first record of search result - if search result is not empty.
     *         null - if there are no records in search result.
     */
    public Record searchChildrenFirst(String indexName, Criterion criterion, Order order);

    /**
     * Returns child record with maximal field(s) value.
     * <p>
     * Children link name and field are defined by index with
     * <code>indexName</code> name.
     * 
     * @see IndexDescriptor
     * @see IndexedField
     * 
     * @param indexName
     * @return child record with maximal indexed field value or null if there
     *         are no children.
     */
    public Record searchMaxChild(String indexName);

    /**
     * Returns child record with minimal field(s) value.
     * <p>
     * Children link name and field are defined by index with
     * <code>indexName</code> name.
     * 
     * @see IndexDescriptor
     * @see IndexedField
     * 
     * @param indexName
     * @return child record with minimal indexed field value or null if there
     *         are no children.
     */
    public Record searchMinChild(String indexName);

    /**
     * Sets field value.
     * <p>
     * Old value is overridden. If value is <string>null</strong> then field is
     * removed.
     * <p>
     * If value is mutable, then it is cloned before storing inside record.
     * 
     * @param fieldName
     *            field name
     * @param value
     *            new value
     * @return old field value, if existed, or null otherwise
     */
    public Object setField(String fieldName, Object value);

    /**
     * Creates new link to parent record.
     * <p>
     * Parent record must belong to the same space as current record.
     * <p>
     * If current record has link with the same name to another parent record,
     * then old link is removed. If parent record is null, then link is removed
     * (if exists).
     * 
     * @param linkName
     *            link name
     * @param parent
     *            new parent record
     */
    public Record setParent(String linkName, Record parent);

    /**
     * Returns <code>String</code> representation of this record.
     * <p>
     * String representation includes:
     * <ol>
     * <li>record identifier</li>
     * <li>field names and their values</li>
     * </ol>
     * 
     * @return string representation
     */
    @Override
    public String toString();

    /**
     * Returns <code>String</code> representation of this record.
     * <p>
     * Returned string includes only those fields, which names are specified by
     * <strong>fieldNames</strong> parameter. Includes all fields if
     * <strong>fieldNames</strong> is null.
     * 
     * @param fieldNames
     *            field names, which will be included in string representation
     * @return string representation
     */
    public String toString(String[] fieldNames);

}
